* Secp256k1 key generation
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
:END:

** Concepts and purpose

*** secp256k1 private key

- secp256k1 private key :: A secp256k1 private key ~k = keccak256(CSPRNG(256
  bits))~ is a 32 bytes random large integer generated by a cryprographically
  secure pseudo-random number generator CSPRNG with 256 bits of entropy e.g.
  tossing a coin 256 times. A private key is used to derive the corresponding
  public key and sign transactions to spend funds from an externally owned
  account EOA or to authenticate users against smart contracts in order to
  invoke smart contract functions from an EOA. A private key is the only piece
  of information required to fully control an EOA. If a private key is lost, the
  funds associated with an EOA are lost forever

*** secp256k1 public key

- secp256k1 public key :: A secp256k1 private key ~K = (x, y) = k x G~ is a
  point with two 32 bytes coordinates ~(x, y)~ on the secp256k1 elliptic curve
  derived from a private key =k= by multiplying the private key by the generator
  point =const G= defined in a standard. The generator point is the same for all
  keys. A public key is used to derive the address of an EOA and to verify
  transaction signatures produced with the corresponding private key. It is
  unfeasible to compute a private key from the corresponding public key
  - Uncompressed public key :: An 65 bytes uncompressed public key ~K = 0x04 +
    x + y~ is the concatenation of the two 32 bytes coordinates ~(x, y)~
    prefixed with the =0x04= prefix
  - Compressed public key :: A 33 bytes compressed public key ~K = 0x02 y even |
    0x03 y odd + x~ is only the 32 bytes =x= coordinate prefixed with either
    =0x02= prefix if the =y= coordinate is even or =0x03= prefix if the =y=
    coordinate is odd. The y coordinate can be unambiguously derived from the x
    coordinate and the parity prefix

*** Ethereum address

- Ethereum address :: An Ethereum address ~a = keccak256(K)[12:]~ is the last 20
  bytes of the Keccak256 hash of the uncompressed public key without the =0x04=
  prefix

** Design and implementation

*** =PubKey= type

- =PubKey= type :: The =PubKey= type represents a secp256k1 public key in both
  the uncompressed and the compressed forms. A public key is constructed from
  the =x= and =y= coordinates of the public key that is the point on the
  secp256k1 elliptic curve
  #+BEGIN_SRC go
type PubKey struct {
  Pub []byte // An uncompressed public key (0x04, x, y) 65 bytes
  Pubc []byte // A compressed public key (0x02 y even | 0x03 y odd, x) 33 bytes
}

func NewPubKey(pubx, puby *big.Int) *PubKey {
  var pub bytes.Buffer
  pub.Write([]byte{0x04})
  pub.Write(pubx.Bytes())
  pub.Write(puby.Bytes())
  var pubc bytes.Buffer
  if new(big.Int).Mod(puby, big.NewInt(2)).Cmp(big.NewInt(0)) == 0 {
    pubc.Write([]byte{0x02})
  } else {
    pubc.Write([]byte{0x03})
  }
  pubc.Write(pubx.Bytes())
  return &PubKey{Pub: pub.Bytes(), Pubc: pubc.Bytes()}
}
  #+END_SRC

*** =PrvKey= type

- =PrvKey= type :: The =PrvKey= type represents a secp256k1 private key and
  embeds the corresponding public key. The private key is constructed from a
  random large integer =d= of the private key and the coordinates =x= and =y= of
  the public key
  #+BEGIN_SRC go
type PrvKey struct {
  PubKey
  Prv []byte // A random large number d 32 bytes
}

func NewPrvKey(prvd, pubx, puby *big.Int) *PrvKey {
  prv := prvd.Bytes()
  pub := NewPubKey(pubx, puby)
  return &PrvKey{Prv: prv, PubKey: *pub}
}
  #+END_SRC

*** Generate a secp256k1 key pair

- Secp256k1 key pair generation :: The =KeyGenerate= function generates a
  secp256k1 private key represented by a random large integer =d= and the
  corresponding secp256k1 public key represented by the coordinates ~(x, y)~ of
  the point on the secp256k1 elliptic curve
  #+BEGIN_SRC go
func KeyGenerate() (*PrvKey, error)  {
  k, err := ecdsa.GenerateKey(ecc.P256k1(), rand.Reader)
  if err != nil {
    return nil, err
  }
  key := NewPrvKey(k.D, k.X, k.Y)
  return key, nil
}
  #+END_SRC

*** Derive a secp256k1 public key from a private key

- Secp256k1 public key derivation :: The =KeyDerive= function derives a
  secp256k1 public key represented by the coordinates ~(x, y)~ of the point on
  the secp256k1 elliptic curve from an externally provided secp256k1 private key
  represented by a random large integer =d=. The coordinate =x= and =y= of the
  public key are derived through the multiplication of the random large integer
  =d= by the constant generator point =G=
  #+BEGIN_SRC go
func KeyDerive(prv []byte) *PrvKey {
  k := &ecdsa.PrivateKey{D: new(big.Int).SetBytes(prv)}
  k.PublicKey.Curve = ecc.P256k1()
  k.PublicKey.X, k.PublicKey.Y = k.PublicKey.ScalarBaseMult(k.D.Bytes())
  key := NewPrvKey(k.D, k.X, k.Y)
  return key
}
  #+END_SRC

*** Derive an Ethereum address from a public key

- Ethereum address :: The =KeyAddress= function derives an Ethereum address from
  an uncompressed public key by taking the last 20 bytes of the Keccak256 hash
  of the uncompressed public key without the =0x04= prefix
  #+BEGIN_SRC go
func KeyAddress(pub []byte) []byte {
  hash := crypto.Keccak256(pub[1:])
  addr := hash[12:]
  return addr
}
  #+END_SRC

** Testing and usage
