* Secp256k1 key generation
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
- [[#concepts-and-purpose][Concepts and purpose]]
  - [[#secp256k1-private-key][secp256k1 private key]]
  - [[#secp256k1-public-key][secp256k1 public key]]
  - [[#ethereum-address][Ethereum address]]
- [[#design-and-implementation][Design and implementation]]
  - [[#pubkey-type][PubKey type]]
  - [[#prvkey-type][PrvKey type]]
  - [[#generate-secp256k1-key-pair][Generate secp256k1 key pair]]
  - [[#derive-secp256k1-public-key-from-private-key][Derive secp256k1 public key from private key]]
  - [[#derive-ethereum-address-from-public-key][Derive Ethereum address from public key]]
- [[#testing-and-usage][Testing and usage]]
  - [[#testing-secp256k1-key-generate-derive-and-address][Testing secp256k1 key generate, derive, and address]]
  - [[#using-key-generate-derive-and-address-cli-commands][Using key generate, derive, and address CLI commands]]
:END:

** Concepts and purpose

*** secp256k1 private key

- secp256k1 private key :: A secp256k1 private key ~k = keccak256(CSPRNG(256
  bits))~ is a 32 bytes random large integer generated by a cryprographically
  secure pseudo-random number generator CSPRNG with 256 bits of entropy e.g.
  tossing a coin 256 times. A private key is used to derive the corresponding
  public key and sign transactions to spend funds from an externally owned
  account EOA or to authenticate users against smart contracts in order to
  invoke smart contract functions from an EOA. A private key is the only piece
  of information required to fully control an EOA. If a private key is lost, the
  funds associated with an EOA are lost forever

*** secp256k1 public key

- secp256k1 public key :: A secp256k1 private key ~K = (x, y) = k x G~ is a
  point with two 32 bytes coordinates ~(x, y)~ on the secp256k1 elliptic curve
  derived from a private key =k= by multiplying the private key by the generator
  point =const G= defined in a standard. The generator point is the same for all
  keys. A public key is used to derive the address of an EOA and to verify
  transaction signatures produced with the corresponding private key. It is
  unfeasible to compute a private key from the corresponding public key
  - Uncompressed public key :: An 65 bytes uncompressed public key ~K = 0x04 +
    x + y~ is the concatenation of the two 32 bytes coordinates ~(x, y)~
    prefixed with the =0x04= prefix
  - Compressed public key :: A 33 bytes compressed public key ~K = 0x02 y even |
    0x03 y odd + x~ is only the 32 bytes =x= coordinate prefixed with either
    =0x02= prefix if the =y= coordinate is even or =0x03= prefix if the =y=
    coordinate is odd. The y coordinate can be unambiguously derived from the x
    coordinate and the parity prefix

*** Ethereum address

- Ethereum address :: An Ethereum address ~a = keccak256(K)[12:]~ is the last 20
  bytes of the Keccak256 hash of the uncompressed public key without the =0x04=
  prefix

** Design and implementation

*** =PubKey= type

- =PubKey= type :: The =PubKey= type represents a secp256k1 public key in both
  the uncompressed and the compressed forms. A public key is constructed from
  the =x= and =y= coordinates of the public key that is the point on the
  secp256k1 elliptic curve
  #+BEGIN_SRC go
type PubKey struct {
  Pub []byte // An uncompressed public key (0x04, x, y) 65 bytes
  Pubc []byte // A compressed public key (0x02 y even | 0x03 y odd, x) 33 bytes
}

func NewPubKey(pubx, puby *big.Int) *PubKey {
  var pub bytes.Buffer
  pub.Write([]byte{0x04})
  pub.Write(pubx.Bytes())
  pub.Write(puby.Bytes())
  var pubc bytes.Buffer
  if new(big.Int).Mod(puby, big.NewInt(2)).Cmp(big.NewInt(0)) == 0 {
    pubc.Write([]byte{0x02})
  } else {
    pubc.Write([]byte{0x03})
  }
  pubc.Write(pubx.Bytes())
  return &PubKey{Pub: pub.Bytes(), Pubc: pubc.Bytes()}
}
  #+END_SRC

*** =PrvKey= type

- =PrvKey= type :: The =PrvKey= type represents a secp256k1 private key and
  embeds the corresponding public key. The private key is constructed from a
  random large integer =d= of the private key and the coordinates =x= and =y= of
  the public key
  #+BEGIN_SRC go
type PrvKey struct {
  PubKey
  Prv []byte // A random large number d 32 bytes
}

func NewPrvKey(prvd, pubx, puby *big.Int) *PrvKey {
  prv := prvd.Bytes()
  pub := NewPubKey(pubx, puby)
  return &PrvKey{Prv: prv, PubKey: *pub}
}
  #+END_SRC

*** Generate secp256k1 key pair

- Secp256k1 key pair generation :: The =KeyGenerate= function generates a
  secp256k1 private key represented by a random large integer =d= and the
  corresponding secp256k1 public key represented by the coordinates ~(x, y)~ of
  the point on the secp256k1 elliptic curve
  #+BEGIN_SRC go
func KeyGenerate() (*PrvKey, error)  {
  k, err := ecdsa.GenerateKey(ecc.P256k1(), rand.Reader)
  if err != nil {
    return nil, err
  }
  key := NewPrvKey(k.D, k.X, k.Y)
  return key, nil
}
  #+END_SRC

*** Derive secp256k1 public key from private key

- Secp256k1 public key derivation :: The =KeyDerive= function derives a
  secp256k1 public key represented by the coordinates ~(x, y)~ of the point on
  the secp256k1 elliptic curve from an externally provided secp256k1 private key
  represented by a random large integer =d=. The coordinate =x= and =y= of the
  public key are derived through the multiplication of the random large integer
  =d= by the constant generator point =G=
  #+BEGIN_SRC go
func KeyDerive(prv []byte) *PrvKey {
  k := &ecdsa.PrivateKey{D: new(big.Int).SetBytes(prv)}
  k.PublicKey.Curve = ecc.P256k1()
  k.PublicKey.X, k.PublicKey.Y = k.PublicKey.ScalarBaseMult(k.D.Bytes())
  key := NewPrvKey(k.D, k.X, k.Y)
  return key
}
  #+END_SRC

*** Derive Ethereum address from public key

- Ethereum address :: The =KeyAddress= function derives an Ethereum address from
  an uncompressed public key by taking the last 20 bytes of the Keccak256 hash
  of the uncompressed public key without the =0x04= prefix
  #+BEGIN_SRC go
func KeyAddress(pub []byte) []byte {
  hash := crypto.Keccak256(pub[1:])
  addr := hash[12:]
  return addr
}
  #+END_SRC

** Testing and usage

*** Testing secp256k1 key generate, derive, and address

Test secp256k1 key generate, derive, and address CLI wallet commands
#+BEGIN_SRC nushell
go build -o wallet; ./key/cli-test.nu
#+END_SRC

*** Using =key= =generate=, =derive=, and =address= CLI commands

Show the help and usage instructions of the =wallet base58= command
#+BEGIN_SRC nushell
./wallet key
# NAME:
#    wallet key - Generate a secp256k1 key pair, sign a transaction, verify a signature

# USAGE:
#    wallet key [command [command options]]

# COMMANDS:
#    generate  Generate a secp256k1 key pair
#                stdout: a secp256k1 key pair in hex in YAML
#    derive    Derive a secp256k1 public key from an external secp256k1 private key
#                stdin: an external secp256k1 private key in hex
#                stdout: a secp256k1 key pair in hex in YAML
#    address   Derive an Ethereum address from a secp256k1 public key
#                stdin: a secp256k1 public key in hex
#                stdout: an Ethereum address in hex

# OPTIONS:
#    --help, -h  show help
#+END_SRC

Generate a secp256k1 key pair. Derive a secp256k1 public key from the externally
provided secp256k1 private key from the initial key generation. Note, that the
derived public key is equal to the originally generated public key.
#+BEGIN_SRC nushell
$env.PATH = $env.PATH | prepend ("." | path expand)
let key = wallet key generate | from yaml
print $key
# ╭──────┬────────────────────────────────────────────────────────────────────────────────────╮
# │ prv  │ 31580adc76247ea9aa72695f93efd627c3ad7ccc3e9fca6bfaaa24c70f822afe                   │
# │ pub  │ 04c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8e51037c0c8341b60 │
# │      │ d68ae18913007bac7b53ff1952c5f0d70dcdcd6afed8e0b6                                   │
# │ pubc │ 02c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8                 │
# ╰──────┴────────────────────────────────────────────────────────────────────────────────────╯
let pub = $key.prv | wallet key derive | from yaml
print $pub
# ╭──────┬────────────────────────────────────────────────────────────────────────────────────╮
# │ prv  │ 31580adc76247ea9aa72695f93efd627c3ad7ccc3e9fca6bfaaa24c70f822afe                   │
# │ pub  │ 04c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8e51037c0c8341b60 │
# │      │ d68ae18913007bac7b53ff1952c5f0d70dcdcd6afed8e0b6                                   │
# │ pubc │ 02c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8                 │
# ╰──────┴────────────────────────────────────────────────────────────────────────────────────╯
#+END_SRC

Take a random secp256k1 private key by keccak256 hashing 32 bytes from the
~/dev/urandom~ CSPRNG. Derive a secp256k1 public key from the private key.
Compute an Ethereum address from the derived public key
#+BEGIN_SRC nushell
$env.PATH = $env.PATH | prepend ("." | path expand)
let prv = open /dev/urandom | first 32 | wallet keccak256
print $prv
# 990c880b9accae50cfd0d928241a80b1afe49b973bea3f92c4253a10cc6321c3
let pub = $prv | wallet key derive | from yaml
print $pub
# ╭──────┬────────────────────────────────────────────────────────────────────────────────────╮
# │ prv  │ 990c880b9accae50cfd0d928241a80b1afe49b973bea3f92c4253a10cc6321c3                   │
# │ pub  │ 04e3694448ca68cc998fb5dddd75af00b703cbe60434b9cde5a1973dc3c212f61bd63b3bfad457ec11 │
# │      │ 04fb42894714fa1848a603fc85bec06ee87dabc5389c95cb                                   │
# │ pubc │ 03e3694448ca68cc998fb5dddd75af00b703cbe60434b9cde5a1973dc3c212f61b                 │
# ╰──────┴────────────────────────────────────────────────────────────────────────────────────╯
let addr = $pub.pub | wallet key address
print $addr
# e207496548c4409addd7ec1061dab0c6bcd2ee42
#+END_SRC
