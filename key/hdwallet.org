* BIP-32 Hierarchical deterministic wallet
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
:END:

** Concepts and purpose

*** HD wallet

- HD wallet :: A hierarchical deterministic HD wallet deterministically derives
  an infinite hierarchy of private and public keys from a single seed of 128 to
  256 bits of entropy. The seed itself is derived from a mnemonic and en
  optional passphrase. Only the mnemonic with an optional passphrase is required
  to backup, export, and import the entire HD wallet with all derived keys. The
  key derivation process is deterministic, so all hierarchy of private and
  public keys can be re-derived from the same mnemonic with an optional
  passphrase. The derived keys are organized in a tree hierarchy with an
  unlimited depth. Different branches of a tree can be used for selective
  sharing and different purposes e.g. different accounts, different
  cryptocurrencies, different accounting purposes.
- Security of derived keys :: While all private and public keys are derived from
  a single mnemonic with an optional passphrase, all derived keys are as secure
  as independently generated keys. To an external observer all derived keys look
  indistinguishable from independently generated keys. There is no feasible way
  to determine whether a key is a child or a sibling of another key. The main
  difference between a HD wallet that derives all keys from a single mnemonic
  with an optional passphrase and a non-deterministic wallet that generates each
  key independently is that only a single mnemonic with an optional passphrase
  is required to backup, export, and import a HD wallet, while every
  independently generated key must be backup as soon as it is generated by a
  non-deterministic wallet. Generating a new receiving address with a new
  spending private key for every transaction is recommended to preserve privacy
  of transactions on a blockchain
- Derivation of public keys :: Public keys to receive funds can be derived in a
  less secure environment e.g. web server from an extended public key without
  having access to the corresponding private extended key to generated
  respective private keys to spend received funds. Later corresponding private
  keys can be derived in a more secure environment e.g. hardware wallet to spend
  received funds

*** Seed derivation

- Seed derivation :: A 512 bits (64 bytes) seed used to derive master extended
  private and public keys of a HD wallet is derived from a 128 to 256 bits
  entropy mnemonic and an optional passphrase. The seed derivation process uses
  the PBKDF2-SHA512 key derivation function with 2048 iterations of the
  HMAC-SHA512 message authentication code function. The mnemonic is used as a
  password and the passphrase is used as a salt for the PBKDF2-SHA512 key
  derivation function. The passphrase, if used, is an additional security
  factor. A mnemonic is useless without a passphrase. A backup of a passphrase
  should be kept in a different place that a backup of a mnemonic. Different
  passphrases result in a completely different set of derived keys. The salt and
  the high number of HMAC-SHA512 iterations makes brute force attacks and
  table-based attacks much more difficult

*** Derivation of extended master keys

- Derivation of extended master keys :: The master extended private and public
  keys are used to derive all other keys in a HD wallet. The master extended
  private key is used to derive all private keys (and all public keys if needed)
  in a HD wallet. The master extended public key can be used to derive only all
  public keys in a HD wallet. The master extended private and public keys are at
  the depth 0 and at the index 0. A 512 bits seed derived from a mnemonic with
  an optional passphrase is used as data and a fixed "Bitcoin seed" string is
  used as a key to the HMAC-SHA512 message authentication code function to
  produce a 512 bits authenticated hash. The first 32 bytes of the authenticated
  hash are used as a master private key. The last (next) 32 bytes of the
  authenticated hash are used as a master chain code needed to derive both child
  private and public keys. The master chain code prevents others from deriving
  child private and public keys if they gained access to the corresponding
  parent private or public key. A master public key is derived from a master
  private key using the secp256k1 curve multiplication by multiplying the master
  private key by the generator point of the secp256k1 elliptic curve. A 64 bytes
  concatenation of a master private key with a master chain code is called a
  master extended private key. A 64 bytes concatenation of a master public key
  with the same master chain code is called a master extended public key

*** Derivation of extended private keys

- Derivation of extended private keys :: The extended private keys are
  identified in the tree hierarchy of a HD wallet by a depth that defines the
  parent-child positioning of keys, and by an index that defines the sibling
  positioning between derived keys. A child private key is derived from the
  corresponding parent extended private key, a depth, and an index of the child
  private key. The parent extended private key is split into a parent private
  key and a parent chain code. Then, a parent public key is derived from the
  parent private key using the secp256k1 multiplication. Next, the HMAC-SHA512
  authenticated hash is computed using a concatenation of the compressed parent
  public key and the index of the child private key as data, and the parent
  chain code as a key. The first 32 bytes of the authenticated hash are used to
  derive a child private key by adding the parent private key to the first 32
  bytes of the authenticated hash. The last (next) 32 bytes of the authenticated
  hash are used as a child chain code. A 64 bytes concatenation of the child
  private key with the child chain code is the extended private key. A child
  public key is derived from the child private key using the secp256k1
  multiplication. A 64 bytes concatenation of the child public key with the
  child chain code is the extended public key

*** Derivation of extended hardened keys

- Derivation of extended hardened keys :: While the extended parent and public
  keys are derived using the parent public compressed key, the hardened extended
  keys are derived using the parent private key prefixed with the =0x00= prefix.
  While the extended parent and public keys use indices between 0 and 2^{31} -
  1, the hardened extended keys use indices between 2^{31} and 2^{32} - 1. A
  hardened child private key is derived from the corresponding parent extended
  private key, a depth, and an index of the hardened child private key starting
  from 2^{31}. The parent extended private key is split into a parent private
  key and a parent chain code. Next, the HMAC-SHA512 authenticated hash is
  computed using a concatenation of the parent private key prefixed with the
  =0x00= prefix and the index of the hardened child private key as data, and the
  parent chain code as a key. The first 32 bytes of the authenticated hash are
  used to derive a hardened child private key by adding the parent private key
  to the first 32 bytes of the authenticated hash. The last (next) 32 bytes of
  the authenticated hash are used as a child chain code. A 64 bytes
  concatenation of the hardened child private key with the child chain code is
  the hardened extended private key. A hardened child public key is derived from
  the hardened child private key using the secp256k1 multiplication. A 64 bytes
  concatenation of the hardened child public key with the child chain code is
  the hardened extended public key

*** Derivation of extended public keys

- Derivation of extended public keys :: A big advantage of the HD wallet key
  derivation mechanism is that extended public keys needed to receive funds can
  be derived in a less secure environment e.g. web server without extended
  private keys needed to spend funds. An child public key is derived from the
  corresponding parent extended public key, a depth, and an index of the child
  public key. The parent extended public key is split into a compressed parent
  public key and a parent chain code. Next, the HMAC-SHA512 authenticated hash
  is computed using a concatenation of the compressed parent public key and the
  index of the child public key as data, and the parent chain code as a key. The
  first 32 bytes of the authenticated hash are used to derive a child public key
  by adding the parent public key to the first 32 bytes of the authenticated
  hash multiplied by the secp256k1 generator point. The last (next) 32 bytes of
  the authenticated hash are used as a child chain code. A 64 bytes
  concatenation of the child public key with the child chain code is the
  extended public key

*** Derivation of extended keys defined by HD path

- HD path :: A HD path uniquely defines an extended private or public key in the
  tree hierarchy of a HD wallet. A HD path starts from either a master private
  key =m= or a master public key =M= and indicates the derivation path by
  appending path segments in the form =/index= for the normal derivation or in
  the form =/index'= for hardened derivation. The indices for hardened
  derivation start from 2^{31}, so this number is automatically added to the
  index of a hardened key e.g. =/0'= means 1 + 2^{31}. Each segment in a HD path
  represents the next level in the tree hierarchy and increments the depth by
  one
| Path   | Description                                                         |
|--------+---------------------------------------------------------------------|
| =m/0=  | The first child private key of the master key (normal derivation)   |
| =M/1'= | The second child public key of the master key (hardened derivation) |

*** Encoding and decoding of extended keys

- Encoding of extended keys :: A 64 bytes concatenation of a 32 bytes private or
  public key with a 32 bytes chain code is called an extended private or public
  key respectively and difficult to manage by humans. A 128 bytes hex
  representation of a 64 bytes extended key is quite large. An encoded extended
  key includes in order a version byte indicating whether the key is private or
  public, a depth of the key from the master, a fingerprint of the compressed
  parent public key, the index of the key from a parent, the chain code, the
  private key prefixed with the =0x00= prefix, or the compressed public key, and
  the error detecting checksum. A 82 bytes concatenation of the above fields in
  order is encoded using the base58 encoding. The base58 encoding of an exteded
  key is less error prone and represents an extended key in a way that humans
  can manage more easily. Along with a prefixed private or a compressed public
  key and the corresponding chain code, an encoded extended key includes the
  following fields in order
| Field      | Size     | Description                                                 |
|------------+----------+-------------------------------------------------------------|
| Version    | 4 bytes  | Private key: version =0x0488ade4=, encoded prefix =xprv=    |
|            |          | Public key: version =0x0488b21e=, encoded prefix =xpub=     |
| Depth      | 1 byte   | Depth of a key from the master                              |
| Parent     | 4 bytes  | First 4 bytes of the hash of a compressed parent public key |
| Index      | 4 bytes  | Index of a key from the parent                              |
| Chain Code | 32 bytes | Chain code                                                  |
| Key        | 33 bytes | Private key prefixed with the =0x00= prefix                 |
|            |          | Compressed public key                                       |
| Checksum   | 4 bytes  | First 4 bytes of the hash of all the above fields           |

- Decoding of extended keys :: The decoding of an encoded extended key converts
  a base58 encoded extended key to its components: a version, a depth, a hash of
  the compressed parent public key, an index, a chain code, a private key, or a
  compressed public key, and an error-detecting checksum. The error detecting
  checksum prevents mistype extended keys from being used by a wallet

** Design and implementation

*** =ExtKey= type

- =ExtKey= type :: The =ExtKey= type represents either an extended private key
  or an extended public key. The extended key type embeds the =PrvKey= type,
  which, in turn, embeds the =PubKey= type. The extended key type is a super set
  of the private key and the public key types. Along with the private key and
  the public key types, the extended key type contains a 32 bytes HD chain code,
  a depth of an extended key from the master key, an index of an extended key
  from the parent key, a base58 encoded extended private key =xprv=, a base58
  encoded extended public key =xpub=
  #+BEGIN_SRC go
type ExtKey struct {
  PrvKey
  Code []byte // A chain code 32 bytes
  Depth uint8 // A depth of an extended key from the master key
  Index uint32 // An index of an extended key from the parent key
  Xprv string // An encoded HD extended private key
  Xpub string // An encoded HD extended public key
}

func NewExtPrvKey(
  prvd, pubx, puby *big.Int, code []byte, depth uint8, index uint32,
) *ExtKey {
  prv := NewPrvKey(prvd, pubx, puby)
  return &ExtKey{PrvKey: *prv, Code: code, Depth: depth, Index: index}
}

func NewExtPubKey(
  pubx, puby *big.Int, code []byte, depth uint8, index uint32,
) *ExtKey {
  pub := NewPubKey(pubx, puby)
  prv := PrvKey{PubKey: *pub}
  return &ExtKey{PrvKey: prv, Code: code, Depth: depth, Index: index}
}
  #+END_SRC

*** Seed derive

- Seed derive :: The =SeedDerive= function takes a mnemonic as data and a
  passphrase as a salt and produces a 512 bits seed by applying the
  PBKDF2-SHA512 key derivation function to the data and the salt with 2048
  iterations of the HMAC-SHA512 message authentication code function. The seed
  derive function
  - Create a salt by prepending a fixed "mnemonic" string to the passphrase
  - Produce a 512 bits seed by applying the PBKDF2-SHA512 key derivation
    function using the mnemonic as data, the salt, and 2048 iterations of the
    HMAC-SHA512 message authentication code function
  #+BEGIN_SRC go
func SeedDerive(mnemonic, passphrase string) []byte {
  salt := []byte("mnemonic" + passphrase)
  seed := crypto.PBKDF2SHA512([]byte(mnemonic), salt, 2048, 64)
  return seed
}
  #+END_SRC

*** Master derive

- Master derive :: The =MasterDerive= function takes a 512 bits seed derived
  from a 128 to 256 bits of entropy and an optional passphrase and derives
  extended master private and public keys. The master derive function
  - Produces a 512 bits authenticated hash using the seed as data and a fixed
    "Bitcoin seed" string as a key
  - The first 32 bytes of the authenticated hash is the master private key
  - The master public key is derived from the master private key by using the
    secp256k1 multiplication
  - The last (next) 32 bytes of the authenticated hash is the master chain code
  - A concatenation of the master private key prefixed with the =0x00= prefix
    with the master chain code is the extended master private key =xprv=
  - A concatenation of the compressed master public key with the master chain
    code is the extended master public key =xpub=
  #+BEGIN_SRC go
func MasterDerive(seed []byte) *ExtKey {
  depth, index := uint8(0), uint32(0)
  hmac := crypto.HMACSHA512(seed, []byte("Bitcoin seed"))
  prv, code := hmac[:32], hmac[32:]
  key := KeyDerive(prv)
  ekey := &ExtKey{PrvKey: *key, Code: code, Depth: depth, Index: index}
  ekey.Xprv = EkeyEncode(xprvVer, depth, nil, index, code, prv)
  ekey.Xpub = EkeyEncode(xpubVer, depth, nil, index, code, ekey.Pubc)
  return ekey
}
  #+END_SRC

*** Private derive

- Private derive :: The =PrivateDerive= function takes an extended private key,
  a depth of a child key from the master key, an index of a child key from the
  parent key, and produces child extended private and public keys. The private
  derive function
  - Split the parent extended private key into a 32 bytes parent private key and
    a 32 bytes parent chain code
  - Derive a parent public key from the parent private key by using the
    secp256k1 multiplication
  - Produce an authenticated hash by using the HMAC-SHA512 message authenticated
    code function with a concatenation of the compressed parent public key and
    the index of the child key as data, and the parent chain code as a key
  - Split the authenticated hash into a 32 bytes child private key base and a 32
    bytes child chain code
  - Add the parent private key to the child private key base to derive the child
    private key
  - Derive a child public key from the child private key by using the secp256k1
    multiplication
  - A concatenation of the child private key prefixed with the =0x00= prefix
    with the child chain code is the extended child private key =xprv=
  - A concatenation of the compressed child public key with the child chain
    code is the extended child public key =xpub=
  #+BEGIN_SRC go
func PrivateDerive(prve []byte, depth uint8, index uint32) *ExtKey {
  parPrv, parCode := prve[:32], prve[32:]
  parKey := KeyDerive(parPrv)
  idx := make([]byte, 4)
  binary.BigEndian.PutUint32(idx, index)
  var data bytes.Buffer
  data.Write(parKey.Pubc) // Parent public compressed
  data.Write(idx)
  hmac := crypto.HMACSHA512(data.Bytes(), parCode)
  prv, code := hmac[:32], hmac[32:]
  prvi := new(big.Int).SetBytes(prv)
  prvi.Add(prvi, new(big.Int).SetBytes(parPrv))
  prvi.Mod(prvi, ecc.P256k1().Params().N)
  key := KeyDerive(prvi.Bytes())
  ekey := &ExtKey{PrvKey: *key, Code: code, Depth: depth, Index: index}
  ekey.Xprv = EkeyEncode(xprvVer, depth, parKey.Pubc, index, code, ekey.Prv)
  ekey.Xpub = EkeyEncode(xpubVer, depth, parKey.Pubc, index, code, ekey.Pubc)
  return ekey
}
  #+END_SRC

*** Hardened derive

- Hardened derive :: The =HardenedDerive= function takes an extended private
  key, a depth of a child key from the master key, an index of a child key from
  the parent key, and produces child hardened extended private and public keys.
  The hardened derive function
  - Split the parent extended private key into a 32 bytes parent private key and
    a 32 bytes parent chain code
  - Derive a parent public key from the parent private key by using the
    secp256k1 multiplication
  - Create a hardened index by adding 2^{31} to the index
  - Produce an authenticated hash by using the HMAC-SHA512 message authenticated
    code function with a concatenation of the parent private key prefixed with
    the =0x00= prefix and the hardened index of the child key as data, and the
    parent chain code as a key
  - Split the authenticated hash into a 32 bytes hardened child private key base
    and a 32 bytes child chain code
  - Add the parent private key to the hardened child private key base to derive
    the hardened child private key
  - Derive a hardened child public key from the hardened child private key by
    using the secp256k1 multiplication
  - A concatenation of the hardened child private key prefixed with the =0x00=
    prefix with the child chain code is the hardened extended child private key
    =xprv=
  - A concatenation of the hardened compressed child public key with the child
    chain code is the hardened extended child public key =xpub=
  #+BEGIN_SRC go
func HardenedDerive(prve []byte, depth uint8, index uint32) *ExtKey {
  parPrv, parCode := prve[:32], prve[32:]
  parKey := KeyDerive(parPrv) // Only for xprv and xpub
  index += uint32(1 << 31) // Hardened key index
  idx := make([]byte, 4)
  binary.BigEndian.PutUint32(idx, index)
  var data bytes.Buffer
  data.WriteByte(0x00)
  data.Write(parPrv) // Parent private prefixed
  data.Write(idx)
  hmac := crypto.HMACSHA512(data.Bytes(), parCode)
  prv, code := hmac[:32], hmac[32:]
  prvi := new(big.Int).SetBytes(prv)
  prvi.Add(prvi, new(big.Int).SetBytes(parPrv))
  prvi.Mod(prvi, ecc.P256k1().Params().N)
  key := KeyDerive(prvi.Bytes())
  ekey := &ExtKey{PrvKey: *key, Code: code, Depth: depth, Index: index}
  ekey.Xprv = EkeyEncode(xprvVer, depth, parKey.Pubc, index, code, ekey.Prv)
  ekey.Xpub = EkeyEncode(xpubVer, depth, parKey.Pubc, index, code, ekey.Pubc)
  return ekey
}
  #+END_SRC

*** Public derive

- Public derive :: The =PublicDerive= function takes an extended public key, a
  depth of a child key from the master key, an index of a child key from the
  parent key, and produces a child extended public key. The public derive
  function
  - Split the parent extended public key into a 32 bytes parent public key and
    a 32 bytes parent chain code
  - Produce an authenticated hash by using the HMAC-SHA512 message authenticated
    code function with a concatenation of the compressed parent public key and
    the index of the child key as data, and the parent chain code as a key
  - Split the authenticated hash into a 32 bytes child public key base and a 32
    bytes child chain code
  - Calculate a point on the secp256k1 elliptic curve by multiplying the child
    public key base by the generator point
  - Add the uncompressed parent public key to the point on the secp256k1
    elliptic curve to derive the child public key
  - A concatenation of the child private key prefixed with the =0x00= prefix
    with the child chain code is the extended child private key =xprv=
  - A concatenation of the compressed child public key with the child chain
    code is the extended child public key =xpub=
  #+BEGIN_SRC go
func PublicDerive(pube []byte, depth uint8, index uint32) *ExtKey {
  parPubc, parCode := pube[:33], pube[33:]
  idx := make([]byte, 4)
  binary.BigEndian.PutUint32(idx, index)
  var data bytes.Buffer
  data.Write(parPubc) // Parent public compressed
  data.Write(idx)
  hmac := crypto.HMACSHA512(data.Bytes(), parCode)
  pb, code := hmac[:32], hmac[32:]
  pub := new(ecdsa.PublicKey)
  pub.Curve = ecc.P256k1()
  pub.X, pub.Y = pub.ScalarBaseMult(pb)
  parX, parY := ecc.UnmarshalCompressed(ecc.P256k1(), parPubc)
  pubx, puby := pub.Add(pub.X, pub.Y, parX, parY)
  ekey := NewExtPubKey(pubx, puby, code, depth, index)
  ekey.Xpub = EkeyEncode(xpubVer, depth, parPubc, index, code, ekey.Pubc)
  return ekey
}
  #+END_SRC

*** Path derive

- Path derive :: The =PathDerive= function takes a mnemonic, an optional
  passphrase, and a HD path, and derives extended private and public keys as
  specified by the HD path e.g. m/0'/1. The path derive function derives a 512
  bits seed from the mnemonic and an optional passphrase. Next, the extended
  master private and public keys are derived from the seed. Then, the HD path is
  parsed into the derivation segments starting from either the master private
  key =m= or the master public key =M=. Each derivation segment increases by one
  the depth of the child keys from the master key. Each derivation segment
  indicates the index of the child key from the parent and whether the normal
  derivation or the hardened derivation marked with the prime ='= symbol has to
  be used. The path derive function process each segment in order starting from
  the extended master private or public key derived from the seed, which, in
  turn, is derived from the mnemonic and an optional passphrase. The extended
  keys derived from the current derivation segment are used as input to derive
  child extended keys from the next derivation segment
  - Private derivation :: If a HD path starts from an extended private key =m=,
    then either the normal private derivation =/index= or the hardened private
    derivation =/index'= is possible. The normal private derivation uses the
    compressed parent public key, while the hardened derivation uses the parent
    private key prefixed with the =0x00= prefix. The input for both the normal
    private derivation and the hardened private derivation is the same: an
    extended parent private key, a depth, and an index of the child private key
  - Public derivation :: If a HD path starts from an extended public key =M=,
    the only the normal public derivation =/index= is possible. The normal
    public derivation uses only the compressed parent public key. The input for
    the normal public derivation is an extended parent public key, a depth, and
    an index fo the child public key
  The path derive function
  - Reject an invalid private =m= or public =M= HD path
  - Derive a 512 bits seed from the mnemonic and an optional passphrase
  - Derive extended private and public keys from the seed
  - For the private derivation
    - Parse the private derivation HD path. For each derivation segment
      - Increase by one the depth of a child key
      - Parse the index of a child key
      - Perform the hardened derivation if the derivation segment indicates the
        hardened derivation, otherwise perform the private derivation by passing
        the extended parent private key, the depth, and the index in both cases
      - Use the derived child private key as input to process the next derivation
        segment
  - For the public derivation
    - Parse the public derivation HD path. For each derivation segment
      - Increase by one the depth of a child key
      - Parse the index of a child key
      - Perform the public derivation by passing the extended parent public key,
        the depth, and the index
      - Use the derived child public key as input to process the next derivation
        segment
  - Return the final extended private or public key
  #+BEGIN_SRC go
func PathDerive(mnemonic, passphrase, path string) (*ExtKey, error) {
  if !rePrvPath.MatchString(path) && !rePubPath.MatchString(path) {
    return nil, fmt.Errorf("path derive: invalid path: %s", path)
  }
  seed := SeedDerive(mnemonic, passphrase)
  ekey := MasterDerive(seed)
  depth := uint8(0)
  if strings.HasPrefix(path, "m") { // Private key derivation
    for _, seg := range rePrvSeg.FindAllStringSubmatch(path, -1) {
      depth++
      index, _ := strconv.ParseInt(seg[1], 10, 32)
      hardened := len(seg[2]) != 0
      prve := append(ekey.Prv, ekey.Code...)
      if hardened {
        ekey = HardenedDerive(prve, depth, uint32(index))
      } else {
        ekey = PrivateDerive(prve, depth, uint32(index))
      }
    }
  } else { // Public key derivation
    for _, seg := range rePubSeg.FindAllStringSubmatch(path, -1) {
      depth++
      index, _ := strconv.ParseInt(seg[1], 10, 32)
      pube := append(ekey.Pubc, ekey.Code...)
      ekey = PublicDerive(pube, depth, uint32(index))
    }
  }
  return ekey, nil
}
  #+END_SRC

*** Extended key encode

- Extended key encode :: The =EkeyEncode= function takes a 4 bytes version
  indicating either a private or a public key has to be encoded, a depth of the
  key from the master key, a compressed parent public key, or a hash of a
  compressed parent key, or =nil= for a master key, an index of the key from the
  parent key, a chain code, a private key or a compressed public key, appends an
  error detecting checksum, and base58 encodes the extended key including all
  the above key information. The extended key encode function
  - Write the 4 bytes version indicating whether a private or a public key has
    to be encoded
  - Write the 1 byte depth of the key from the master key
  - Write the first 4 bytes of the hash of the compressed parent public key. The
    parent hash is the combination of ~RIPEMD160(SHA256(parent.pubc))~. The
    parent has of a master key is =0x00000000=
  - Write the 4 bytes index of the key from the parent key
  - Write either the 33 bytes private key prefixed with the =0x00= prefix or the
    33 bytes compressed public key
  - Write the first 4 bytes of the error detecting checksum. The hash of the
    error detecting checksum is the double SHA256 hash of the above data
  - Base58 encode the 82 bytes data including the checksum
  - Return the base58 encoded extended private or public key
  #+BEGIN_SRC go
func EkeyEncode(
  version []byte, depth uint8, parent []byte, index uint32, code, key []byte,
) string {
  var data bytes.Buffer
  data.Write(version)
  data.Write([]byte{depth})
  switch {
  case parent == nil: // Master key
    data.Write([]byte{0x00, 0x00, 0x00, 0x00})
  case len(parent) == 4: // Parent hash
    data.Write(parent)
  default: // Parent pubc
    hash := crypto.RIPEMD160(crypto.SHA256(parent))
    data.Write(hash[:4])
  }
  idx := make([]byte, 4)
  binary.BigEndian.PutUint32(idx, index)
  data.Write(idx)
  data.Write(code)
  if len(key) == 32 { // Private key
    data.Write([]byte{0x00})
  }
  data.Write(key)
  csum := crypto.SHA256(crypto.SHA256(data.Bytes()))
  data.Write(csum[:4])
  str := crypto.Base58Enc(data.Bytes())
  return str
}
  #+END_SRC

*** Extended key decode

- Extended key decode :: The =EkeyDecode= function takes an encoded extended
  private or public key and decodes the key into an extended private or public
  key, the depth of the key from the master key, and the index of the key from
  the parent key. The extended key decode function checks the embedded error
  detecting checksum and rejects invalid keys. The exteded key decode function
  - Base58 decode the encoded extended private or public key
  - Reject an invalid key if the embedded checksum does not match the computed
    checksum
  - Parse the 4 bytes version
  - Parse the 1 byte depth of the key from the master key
  - Parse the 4 bytes hash of the compressed parent public key
  - Parse the 4 bytes index of the key from the parent key
  - Parse the 32 bytes chain code
  - Parse either the 33 bytes private key prefixed with the =0x00= prefix or the
    33 bytes compressed public key
  - Return either the extended private key or the extended public key
  #+BEGIN_SRC go
func EkeyDecode(str string) (*ExtKey, error) {
  data, err := crypto.Base58Dec(str)
  if err != nil {
    return nil, err
  }
  csum := data[78:]
  hash := crypto.SHA256(crypto.SHA256(data[:78]))
  if !slices.Equal(hash[:4], csum) {
    return nil, fmt.Errorf("extended key decode: invalid checksum")
  }
  version := data[:4]
  depth := uint8(data[4])
  parent := data[5:9]
  index := binary.BigEndian.Uint32(data[9:13])
  code := data[13:45]
  if slices.Equal(version, xprvVer) { // Decode a private key
    prv := data[46:78]
    key := KeyDerive(prv)
    ekey := &ExtKey{PrvKey: *key, Code: code, Depth: depth, Index: index}
    ekey.Xprv = EkeyEncode(xprvVer, depth, parent, index, code, ekey.Prv)
    ekey.Xpub = EkeyEncode(xpubVer, depth, parent, index, code, ekey.Pubc)
    return ekey, nil
  } else { // Decode a public key
    pubc := data[45:78]
    pubx, puby := ecc.UnmarshalCompressed(ecc.P256k1(), pubc)
    ekey := NewExtPubKey(pubx, puby, code, depth, index)
    ekey.Xpub = EkeyEncode(xpubVer, depth, parent, index, code, ekey.Pubc)
    return ekey, nil
  }
}
  #+END_SRC

** Testing and usage

*** Testing all HD wallet CLI commands

#+BEGIN_SRC nushell
go build -o wallet; ./key/cli-test.nu
#+END_SRC

*** Using =hd seed= and =hd master= CLI commands
*** Using =hd private= and =hd hardened= CLI commands
*** Using =hd public= CLI commands
*** Using =hd path= CLI commands
*** Using =hd decode= CLI commands
