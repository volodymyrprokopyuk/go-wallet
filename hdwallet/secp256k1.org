* Secp256k1 keys and ECDSA signatures
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
- [[#concepts-and-purpose][Concepts and purpose]]
  - [[#secp256k1-private-key][secp256k1 private key]]
  - [[#secp256k1-public-key][secp256k1 public key]]
  - [[#ecdsa-signing-a-message][ECDSA signing a message]]
  - [[#ecdsa-verifying-a-signature][ECDSA verifying a signature]]
  - [[#ecdsa-recovering-a-public-key][ECDSA recovering a public key]]
- [[#design-and-implementation][Design and implementation]]
  - [[#pubkey-type][PubKey type]]
  - [[#prvkey-type][PrvKey type]]
  - [[#secp256k1-key-generate][Secp256k1 key generate]]
  - [[#secp256k1-key-derive][Secp256k1 key derive]]
  - [[#ecdsa-sign][ECDSA sign]]
  - [[#ecdsa-verify][ECDSA verify]]
  - [[#ecdsa-recover][ECDSA recover]]
- [[#testing-and-usage][Testing and usage]]
  - [[#testing-all-eckey--and-ecdsa--cli-commands][Testing all eckey * and ecdsa * CLI commands]]
  - [[#using-eckey-generate-and-eckey-derive-cli-commands][Using eckey generate and eckey derive CLI commands]]
  - [[#using-ecdsa-sign-ecdsa-verify-and-ecdsa-recover-cli-commands][Using ecdsa sign, ecdsa verify, and ecdsa recover CLI commands]]
:END:

** Concepts and purpose

*** secp256k1 private key

- secp256k1 private key :: A secp256k1 private key ~k =
  keccak256(CSPRNG(256bits))~ is a 32 bytes random large integer generated by a
  cryprographically secure pseudo-random number generator CSPRNG with 256 bits
  of entropy e.g. tossing a coin 256 times. A private key is used to derive the
  corresponding public key and sign transactions to spend funds from an
  externally owned account EOA or to authenticate users against smart contracts
  in order to invoke smart contract functions from an EOA. A private key is the
  only piece of information required to fully control an EOA. If a private key
  is lost, the funds associated with an EOA are lost forever

*** secp256k1 public key

- secp256k1 public key :: A secp256k1 private key ~K = (x, y) = k x G~ is a
  point with two 32 bytes coordinates ~(x, y)~ on the secp256k1 elliptic curve
  derived from a private key =k= by multiplying the private key by the generator
  point =const G= defined in a standard. The generator point is the same for all
  keys. A public key is used to derive the address of an EOA and to verify
  transaction signatures produced with the corresponding private key. It is
  unfeasible to compute a private key from the corresponding public key
  - Uncompressed public key :: An 65 bytes uncompressed public key ~K = 0x04 +
    x + y~ is the concatenation of the two 32 bytes coordinates ~(x, y)~
    prefixed with the =0x04= prefix
  - Compressed public key :: A 33 bytes compressed public key ~K = 0x02 y even |
    0x03 y odd + x~ is only the 32 bytes =x= coordinate prefixed with either
    =0x02= prefix if the =y= coordinate is even or =0x03= prefix if the =y=
    coordinate is odd. The y coordinate can be unambiguously derived from the x
    coordinate and the parity prefix

*** ECDSA signing a message

*** ECDSA verifying a signature

*** ECDSA recovering a public key

** Design and implementation

*** =PubKey= type

- =PubKey= type :: The =PubKey= type represents a secp256k1 public key in both
  the uncompressed and the compressed forms. A public key is constructed from
  the =x= and =y= coordinates of the public key that is the point on the
  secp256k1 elliptic curve
  #+BEGIN_SRC go
type PubKey struct {
  Pub []byte // An uncompressed public key (0x04, x, y) 65 bytes
  Pubc []byte // A compressed public key (0x02 y even | 0x03 y odd, x) 33 bytes
}

func NewPubKey(pubx, puby *big.Int) *PubKey {
  var pub bytes.Buffer
  pub.Write([]byte{0x04})
  pub.Write(pubx.Bytes())
  pub.Write(puby.Bytes())
  var pubc bytes.Buffer
  if new(big.Int).Mod(puby, big.NewInt(2)).Cmp(big.NewInt(0)) == 0 {
    pubc.Write([]byte{0x02})
  } else {
    pubc.Write([]byte{0x03})
  }
  pubc.Write(pubx.Bytes())
  return &PubKey{Pub: pub.Bytes(), Pubc: pubc.Bytes()}
}
  #+END_SRC

*** =PrvKey= type

- =PrvKey= type :: The =PrvKey= type represents a secp256k1 private key and
  embeds the corresponding public key. The private key is constructed from a
  random large integer =d= of the private key and the coordinates =x= and =y= of
  the public key
  #+BEGIN_SRC go
type PrvKey struct {
  PubKey
  Prv []byte // A random large number d 32 bytes
}

func NewPrvKey(prvd, pubx, puby *big.Int) *PrvKey {
  prv := prvd.Bytes()
  pub := NewPubKey(pubx, puby)
  return &PrvKey{Prv: prv, PubKey: *pub}
}
  #+END_SRC

*** Secp256k1 key generate

- Secp256k1 key generate :: The =KeyGenerate= function generates a secp256k1
  private key represented by a random large integer =d= and the corresponding
  secp256k1 public key represented by the coordinates ~(x, y)~ of the point on
  the secp256k1 elliptic curve
  #+BEGIN_SRC go
func KeyGenerate() (*PrvKey, error)  {
  k, err := ecdsa.GenerateKey(ecc.P256k1(), rand.Reader)
  if err != nil {
    return nil, err
  }
  key := NewPrvKey(k.D, k.X, k.Y)
  return key, nil
}
  #+END_SRC

*** Secp256k1 key derive

- Secp256k1 key derive :: The =KeyDerive= function derives a secp256k1 public
  key represented by the coordinates ~(x, y)~ of the point on the secp256k1
  elliptic curve from an externally provided secp256k1 private key represented
  by a random large integer =d=. The coordinate =x= and =y= of the public key
  are derived through the multiplication of the random large integer =d= by the
  constant generator point =G=
  #+BEGIN_SRC go
func KeyDerive(prv []byte) *PrvKey {
  k := &ecdsa.PrivateKey{D: new(big.Int).SetBytes(prv)}
  k.PublicKey.Curve = ecc.P256k1()
  k.PublicKey.X, k.PublicKey.Y = k.PublicKey.ScalarBaseMult(k.D.Bytes())
  key := NewPrvKey(k.D, k.X, k.Y)
  return key
}
  #+END_SRC

*** ECDSA sign

- ECDSA sign ::

*** ECDSA verify

- ECDSA verify ::

*** ECDSA recover

- ECDSA recover ::

** Testing and usage

*** Testing all =eckey *= and =ecdsa *= CLI commands

#+BEGIN_SRC nushell
go build -o wallet; ./key/cli-test.nu
#+END_SRC

*** Using =eckey generate= and =eckey derive= CLI commands

Show the help and usage instructions of the =wallet eckey= command
#+BEGIN_SRC nushell
./wallet eckey
# NAME:
#    wallet eckey - Generate a secp256k1 key pair. Derive a secp256k1 public key

# USAGE:
#    wallet eckey [command [command options]]

# COMMANDS:
#    generate  Generate a secp256k1 key pair
#                stdout: a secp256k1 key pair in hex in YAML
#    derive    Derive a secp256k1 public key from an external secp256k1 private key
#                stdin: an external secp256k1 private key in hex
#                stdout: a secp256k1 key pair in hex in YAML

# OPTIONS:
#    --help, -h  show help
#+END_SRC

Generate a secp256k1 key pair. Derive a secp256k1 public key from the externally
provided secp256k1 private key from the initial key generation. Note, that the
derived public key is equal to the originally generated public key.
#+BEGIN_SRC nushell
$env.PATH = $env.PATH | prepend ("." | path expand)
let key = wallet eckey generate | from yaml
print $key
# ╭──────┬────────────────────────────────────────────────────────────────────────────────────╮
# │ prv  │ 31580adc76247ea9aa72695f93efd627c3ad7ccc3e9fca6bfaaa24c70f822afe                   │
# │ pub  │ 04c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8e51037c0c8341b60 │
# │      │ d68ae18913007bac7b53ff1952c5f0d70dcdcd6afed8e0b6                                   │
# │ pubc │ 02c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8                 │
# ╰──────┴────────────────────────────────────────────────────────────────────────────────────╯
let pub = $key.prv | wallet eckey derive | from yaml
print $pub
# ╭──────┬────────────────────────────────────────────────────────────────────────────────────╮
# │ prv  │ 31580adc76247ea9aa72695f93efd627c3ad7ccc3e9fca6bfaaa24c70f822afe                   │
# │ pub  │ 04c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8e51037c0c8341b60 │
# │      │ d68ae18913007bac7b53ff1952c5f0d70dcdcd6afed8e0b6                                   │
# │ pubc │ 02c0eb637fe1ac067560860697e929a78fd2d743c642b7c601535cacc1ec1708e8                 │
# ╰──────┴────────────────────────────────────────────────────────────────────────────────────╯
#+END_SRC

*** Using =ecdsa sign=, =ecdsa verify=, and =ecdsa recover= CLI commands

Show the help and usage instructions of the =wallet ecdsa= command
#+BEGIN_SRC nushell
./wallet ecdsa
# NAME:
#    wallet ecdsa - Sign a hash using the ECDSA. Verify a signature. Recover a public key

# USAGE:
#    wallet ecdsa [command [command options]]

# COMMANDS:
#    sign     Sign a hash using the ECDSA over the secp256k1 elliptic curve
#               stdin: a hash in hex
#               stdout: a signature of the hash in hex
#    verify   Verify a signature using the ECDSA over the secp256k1 elliptic curve
#               stdin: a hash in hex
#               stdout: true if the signature is valid, false otherwise
#    recover  Recover a public key from a hash and its ECDSA signature
#               stdin: a hash in hex
#               stdout: a public key in hex in YAML

# OPTIONS:
#    --help, -h  show help
#+END_SRC
